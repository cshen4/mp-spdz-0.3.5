from Compiler.util import if_else

player_num = 3
candidates_num = 4

candidate_votes = Matrix(candidates_num, player_num, sint)

# use @for_range_opt for balanced optimization
# but use Python loops if compile-time numbers are need (e.g., for players)

@for_range_opt(candidates_num)
def _(i):
    for j in range(player_num):
        candidate_votes[i][j] = sfix.get_input_from(j)
    

for candidate_vote in candidate_votes:
    print_ln('candidate_vote: %s', candidate_vote.reveal())

#Verify vote count for each player
expected_total = 10 # 4 + 3 + 2 + 1

@for_range(player_num)
def _(i):
    count = 0
    for j in range(candidates_num):
        count += candidate_votes[j][i]
    print_ln(count.reveal())
    print_ln(expected_total)
    if count != expected_total:
        print_ln('Invalid votes')

max_value = Array(1, sint)
max_value[0] = sum(candidate_votes[0])
win_candidate_index = Array(1, sint)
win_candidate_index[0] = 0

@for_range(candidates_num - 1)
def loop_body(offset):
    index = 1 + offset;
    candidate_sum = sum(candidate_votes[index])
    print_ln("index: %s, current_sum: %s", index, candidate_sum.reveal())
    # Is this client input a new maximum, will be sint(1) if true, else sint(0)
    is_new_max = max_value[0] < candidate_sum
    # Keep latest max_value
    max_value[0] = if_else(is_new_max, candidate_sum, max_value[0])
    # Keep current winning client id
    win_candidate_index[0] = if_else(is_new_max, index, win_candidate_index[0])

print_ln('maximum: %s', max_value[0].reveal())
print_ln('winning index: %s', win_candidate_index[0].reveal())

